# Kod nienadzorowany i wzorce projektowe

## Autor: Tomasz Hachaj

Treść:
- [Wywoływanie funkcji z niezarządzanej bibliotek (DLL)](#wywoływanie-funkcji-z-niezarządzanej-bibliotek-dll)
- [Wzorce projektowe](#wzorce-projektowe)
    - [Creational Patterns](#creational-patterns)
        - [Abstract Factory](#abstract-factory)
        - [Builder](#builder)
        - [Factory Method](#factory-method)
        - [Prototype](#prototype)
        - [Singleton](#singleton)
    - [Structural Patterns](#structural-patterns)
        - [Adapter](#adapter)
        - [Bridge](#bridge) 
        - [Composite](#composite)
        - [Decorator](#decorator)
        - [Facade](#fasada-facade)
        - [Flyweight](#flyweight)
        - [Proxy](#proxy)
    - [Behavioral Patterns](#behavioral-patterns)
        - [Chain of Resp](#chain-of-resp)
        - [Command](#command)
        - [Interpreter](#interpreter)
        - [Iterator](#iterator)
        - [Mediator](#mediator)
        - [Memento](#memento)
        - [Observer](#observer)
        - [State](#state)
        - [Strategy](#strategy)
        - [Template Method](#template-method)
        - [Visitor](#visitor)

## Wywoływanie funkcji z niezarządzanej bibliotek (DLL)

Jeżeli chcemy wywołać kod niezarządzany, który znajduje się w systemowej bibliotece z poziomu zarządzanego C# warto sprawdzić, czy sygnatura odpowiedniej funkcji znajduje się na stronie PInvoke.net [link](http://www.pinvoke.net/).

PInvoke.net to wiki, pozwalające programistom na wyszukiwanie, edytowanie i dodawanie sygnatur PInvoke*, typów zdefiniowanych przez użytkownika oraz wszelkich innych informacji związanych z wywoływaniem Win32 i innych niezarządzanych API z kodu zarządzanego (napisanego w językach takich jak C# czy VB.NET).

Najczęściej tego typu wywołania wykorzystuje się do pisania wrapperów niezarządzanych bibliotek.

Mapowanie typów pomiędzy kodem zarządzanym i niezarządzanym odbywa się poprzez klasę Marshall i pokrewne [link](https://learn.microsoft.com/pl-pl/dotnet/api/system.runtime.interopservices.marshal?view=net-7.0)[link](https://learn.microsoft.com/pl-pl/dotnet/api/system.runtime.interopservices.marshalasattribute?view=net-7.0).  

```cs

using System.Runtime.InteropServices;
class PInvoke1App
{
    [DllImport("user32.dll")]
    static extern int MessageBoxA(int hWnd,
                                  string strMsg,
                                  string strCaption,
                                  int iType);
    public enum beepType : uint
    {
        /// A simple windows beep
        SimpleBeep  = 0xFFFFFFFF,
        /// A standard windows OK beep
        OK    = 0x00,
        /// A standard windows Question beep
        Question  = 0x20,
        /// A standard windows Exclamation beep
        Exclamation  = 0x30,
        /// A standard windows Asterisk beep
        Asterisk  = 0x40,
    }

    [DllImport("User32.dll", ExactSpelling=true)]
    private static extern bool MessageBeep(uint type);

    public static void beep(beepType type)
    {
        MessageBeep((uint)type);
    }

    [StructLayout(LayoutKind.Sequential)]
    struct POINT
    {
        public Int32 X;
        public Int32 Y;
    }

    [DllImport("user32.dll")]
    //atrybut wskazujący, w jaki sposób zmapować zwracaną zmienną na kod zarządzany
    [return: MarshalAs(UnmanagedType.Bool)]
    static extern bool GetCursorPos(out POINT point);
    public static void Main()
    {
        //dźwięk systemowy
        MessageBeep((uint)beepType.Asterisk);
        MessageBoxA(0, "Zaraz zaczniemy śledzić myszkę.\nNaciśnij klawisz aby zamknąć.",
            "Aplikacja", 0);
        bool koniec = false;
        Task t = new Task(() => {
            POINT prev = new POINT();
            POINT p = new POINT();
            while (!koniec){
                GetCursorPos(out p);
                if (prev.X != p.X || prev.Y != p.Y) {
                    Console.WriteLine("X=" + p.X + ";" + "Y=" + p.Y);
                }
                prev.X = p.X;
                prev.Y = p.Y;
                Task.Delay(1).Wait();
            }
        });
        t.Start();
        Console.ReadKey();
        koniec = true;
    }
}

```

Kod zarządzany nie ma bezpośredniego dostępu do pamięci przy użyciu wskaźników. Nie alokuje również bezpośrednio pamięci ale zamiast tego tworzy obiekty zarządzane za pośrednictwem maszyny wirtualnej. 

C# obsługuje kontekst unsafe, w którym można pisać kod niezarządzany. W kontekście unsafe, kod może używać wskaźników, alokować i zwalniać bloki pamięci oraz wywoływać metody używając wskaźników funkcji. Niebezpieczny kod w C# niezarządzane (unsafe - niebezpieczny) niekoniecznie jest niebezpieczny; jest to po prostu kod, którego bezpieczeństwo pod względem zarządzania pamięci nie jest gwarantowane przez maszynę wirtualną.

Niezarządzany kod ma następujące właściwości:
- Metody, typy i bloki kodu mogą być zdefiniowane jako niezarządzane
- W niektórych przypadkach, niezarządzany kod może zwiększyć wydajność aplikacji poprzez usunięcie kontroli granic tablic.
- Niezarządzany kod jest wymagany podczas wywoływania funkcji natywnych, które wymagają wskaźników.
- Używanie niezarządzanego kodu wprowadza zagrożenia bezpieczeństwa i stabilności całego rozwiązania, ponieważ przy pomocy wskaźników z ominięciem maszyny wirtualnej mamy bezpośredni dostęp do pamięci. 
- Kod zawierający niebezpieczne bloki musi być skompilowany z opcją kompilatora AllowUnsafeBlocks.

Aby mieć możliwość kompilacji i uruchomienia kodu niezarządzanego do pliku projektu *.csproj należy dodać definicję<AllowUnsafeBlocks>true</AllowUnsafeBlocks> na przykład:

```cs

<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
    <OutputType>Exe</OutputType>
    <TargetFramework>net7.0</TargetFramework>
    <RootNamespace>Programowanie_obiektowe</RootNamespace>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
  </PropertyGroup>
</Project>

```

Poniższy kod przedstawia przykład zastosowania bloku unsafe w celu niezarządzanego dostępu do pamięci[link](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/unsafe-code)

```cs

class Program {
    public static void Main(){        
        // referencja do tablicy int[]
        int[] tablica = new int[5] { 10, 20, 30, 40, 50 };
        int dlugoscTablicy = tablica.Length;
        // musimy użyć bloku unsafe aby mieć dostęp do wskaźników
        unsafe
        {
            // Instrukcja fixed zapobiega przeniesieniu zmiennej przenoszonej przez moduł 
            // garbage collector i deklaruje wskaźnik do tej zmiennej. 
            // Adres stałej lub przypiętej zmiennej nie zmienia się podczas wykonywania instrukcji. 
            // Zadeklarowany wskaźnik można użyć tylko wewnątrz bloku fixed. 
            // Zadeklarowany wskaźnik jest odczytywany i nie można go modyfikować.
            fixed (int* p = &tablica[0])
            {
                // p jest przypięty (ustalony, fixed), więc tworzymy nowy wskaźnik, 
                // aby była możliwość modyfikacji wskaźnik
                int* p2 = p;
                for (int a = 0; a < dlugoscTablicy; a++)
                {
                    Console.WriteLine(p2[0]);
                    p2++;
                }
            }
        }
    }
}

```

Możemy również wywoływać metody powiązane z danym typem danych [link](https://www.codeproject.com/Articles/1099/Writing-Unsafe-code-using-C)

```cs

class KodNiezarzadzany {
	public static void Main() {
		funkcjaNiezarzadzana();
	}

	public static unsafe void funkcjaNiezarzadzana() {
		int liczba = 10;
        //pobranie referencji do obiektu
		int* pliczba = &liczba;
		Console.WriteLine("Data is " + liczba);
        //z poziomu lodu niezarządzanego jest dostęp do metod danego typu danych
        Console.WriteLine("Data is " + pliczba->ToString() );
        //pobranie adresu wskaźnika
		Console.WriteLine("Address is " + (int)pliczba );
	}
}

```

## Wzorce projektowe

Wzorce projektowe służą do modelowania konstrukcji programistycznych, które mogą być użyteczne do rozwiązywania typowych problemów, które można napotkać w projektach informatycznych. Poniższe kody opracowano na podstawie [link](https://www.dofactory.com/net/design-patterns). Ilustracje pochodzą również z [link](https://www.dofactory.com/net/design-patterns).

### Creational Patterns

#### Abstract Factory 

Wzorzec projektowy Abstract Factory zapewnia interfejs do tworzenia rodzin powiązanych lub zależnych obiektów bez określania ich konkretnych klas.

![abstractfactory.png](img/abstractfactory.png)

Struktura klas i obiektów:

- AbstractFactory  (PrzedsiebiorstwoAbstractFactory) - deklaruje interfejs dla operacji, które tworzą abstrakcyjne produkty
- ConcreteFactory   (PrzedsiebiorstwoAFactory, PrzedsiebiorstwoBFactory) - implementuje operacje tworzenia konkretnych obiektów produktów
- AbstractProduct (Zespol, Pracownik) - deklaruje abstrakcyjne klasy dla obiektów, które będą częścią składową skonkretyzowanych fabryk 
- Product  (ZespolA, ZespolB, PracownikA, PracownikB) - definiuje obiekt, który ma być utworzony przez odpowiednią skonkretyzowaną fabrykę implementuje abstrakcyjną klasę AbstractProduct 
- Client  (Przedsiebiorstwa) - używa metod zadeklarowanych przez klasy AbstractFactory i AbstractProduct 

```cs

namespace WzoreceProjektowe
{
    class Program
    {
        public static void Main()
        {
            PrzedsiebiorstwoAbstractFactory pA = new PrzedsiebiorstwoAFactory();
            Przedsiebiorstwa przedsiebiorstwo = new Przedsiebiorstwa(pA);
            przedsiebiorstwo.UruchomPrace();

            PrzedsiebiorstwoAbstractFactory pB = new PrzedsiebiorstwoBFactory();
            przedsiebiorstwo = new Przedsiebiorstwa(pB);
            przedsiebiorstwo.UruchomPrace();
        }
    }

    abstract class PrzedsiebiorstwoAbstractFactory
    {
        public abstract Pracownik StworzPracownikow();
        public abstract Zespol StworzZespoly();
    }

    class PrzedsiebiorstwoAFactory : PrzedsiebiorstwoAbstractFactory
    {
        public override PracownikA StworzPracownikow()
        {
            return new PracownikA();
        }
        public override ZespolA StworzZespoly()
        {
            return new ZespolA();
        }
    }

    class PrzedsiebiorstwoBFactory : PrzedsiebiorstwoAbstractFactory
    {
        public override PracownikB StworzPracownikow()
        {
            return new PracownikB();
        }
        public override ZespolB StworzZespoly()
        {
            return new ZespolB();
        }
    }

    abstract class Zespol
    {
    }

    abstract class Pracownik
    {
        public abstract void PracujeWZespole(Zespol z);
    }

    class ZespolA : Zespol
    {
    }

    class PracownikA : Pracownik
    {
        public override void PracujeWZespole(Zespol z)
        {
            Console.WriteLine(this.GetType().Name +
              " pracuje w zespole " + z.GetType().Name);
        }
    }

    class ZespolB : Zespol
    {
    }

    class PracownikB : Pracownik
    {
        public override void PracujeWZespole(Zespol z)
        {
            Console.WriteLine(this.GetType().Name +
              " pracuje w zespole " + z.GetType().Name);
        }
    }

    class Przedsiebiorstwa
    {
        private Pracownik _pracownik;
        private Zespol _zespol;
        // Constructor
        public Przedsiebiorstwa(PrzedsiebiorstwoAbstractFactory factory)
        {
            _pracownik = factory.StworzPracownikow();
            _zespol = factory.StworzZespoly();
        }
        public void UruchomPrace()
        {
            _pracownik.PracujeWZespole(_zespol);
        }
    }
}

```

#### Builder 	

Wzorzec projektowy Builder oddziela konstrukcję złożonego obiektu od jego reprezentacji, dzięki czemu ten sam proces konstrukcyjny może tworzyć różne reprezentacje.

![builder.png](img/builder.png)

Struktura klas i obiektów:
- Konstruktor (VehicleBuilder) - określa abstrakcyjny interfejs do tworzenia części obiektu Product
- ConcreteBuilder (MotorCycleBuilder, CarBuilder, ScooterBuilder) - konstruuje i składa części produktu poprzez implementację interfejsu Builder
- Dyrektor (Shop) - konstruuje obiekt używając interfejsu Builder
- Produkt (Pojazd) - reprezentuje złożony obiekt w trakcie budowy. ConcreteBuilder buduje wewnętrzną reprezentację produktu i definiuje proces, w którym jest on montowany - zawiera klasy, które definiują części składowe, w tym interfejsy do składania części w końcowy rezultat

```cs

public class Program
{
    public static void Main()
    {
        VehicleBuilder builder;
        // Create shop with vehicle builders
        Shop shop = new Shop();
        // Construct and display vehicles
        builder = new ScooterBuilder();
        shop.Construct(builder);
        builder.Vehicle.Show();
        builder = new CarBuilder();
        shop.Construct(builder);
        builder.Vehicle.Show();
        builder = new MotorCycleBuilder();
        shop.Construct(builder);
        builder.Vehicle.Show();
    }
}
// The 'Director' class
class Shop
{
    // Builder uses a complex series of steps
    public void Construct(VehicleBuilder vehicleBuilder)
    {
        vehicleBuilder.BuildFrame();
        vehicleBuilder.BuildEngine();
        vehicleBuilder.BuildWheels();
        vehicleBuilder.BuildDoors();
    }
}
// The 'Builder' abstract class
abstract class VehicleBuilder
{
    protected Vehicle vehicle;
    // Gets vehicle instance
    public Vehicle Vehicle
    {
        get { return vehicle; }
    }
    // Abstract build methods
    public abstract void BuildFrame();
    public abstract void BuildEngine();
    public abstract void BuildWheels();
    public abstract void BuildDoors();
}
// The 'ConcreteBuilder1' class
class MotorCycleBuilder : VehicleBuilder
{
    public MotorCycleBuilder()
    {
        vehicle = new Vehicle("MotorCycle");
    }
    public override void BuildFrame()
    {
        vehicle["frame"] = "MotorCycle Frame";
    }
    public override void BuildEngine()
    {
        vehicle["engine"] = "500 cc";
    }
    public override void BuildWheels()
    {
        vehicle["wheels"] = "2";
    }
    public override void BuildDoors()
    {
        vehicle["doors"] = "0";
    }
}
// The 'ConcreteBuilder2' class
class CarBuilder : VehicleBuilder
{
    public CarBuilder()
    {
        vehicle = new Vehicle("Car");
    }
    public override void BuildFrame()
    {
        vehicle["frame"] = "Car Frame";
    }
    public override void BuildEngine()
    {
        vehicle["engine"] = "2500 cc";
    }
    public override void BuildWheels()
    {
        vehicle["wheels"] = "4";
    }
    public override void BuildDoors()
    {
        vehicle["doors"] = "4";
    }
}
// The 'ConcreteBuilder3' class
class ScooterBuilder : VehicleBuilder
{
    public ScooterBuilder()
    {
        vehicle = new Vehicle("Scooter");
    }
    public override void BuildFrame()
    {
        vehicle["frame"] = "Scooter Frame";
    }
    public override void BuildEngine()
    {
        vehicle["engine"] = "50 cc";
    }
    public override void BuildWheels()
    {
        vehicle["wheels"] = "2";
    }
    public override void BuildDoors()
    {
        vehicle["doors"] = "0";
    }
}
// The 'Product' class
class Vehicle
{
    private string _vehicleType;
    private Dictionary<string, string> _parts =
        new Dictionary<string, string>();
    // Constructor
    public Vehicle(string vehicleType)
    {
        this._vehicleType = vehicleType;
    }
    // Indexer
    public string this[string key]
    {
        get { return _parts[key]; }
        set { _parts[key] = value; }
    }
    public void Show()
    {
        Console.WriteLine("\n---------------------------");
        Console.WriteLine("Vehicle Type: {0}", _vehicleType);
        Console.WriteLine(" Frame : {0}", _parts["frame"]);
        Console.WriteLine(" Engine : {0}", _parts["engine"]);
        Console.WriteLine(" #Wheels: {0}", _parts["wheels"]);
        Console.WriteLine(" #Doors : {0}", _parts["doors"]);
    }
}

```

#### Factory Method

Wzorzec projektowy Factory Method definiuje interfejs do tworzenia obiektu, ale pozwala podklasom zdecydować, która klasa ma być instancją. 

![factorymethod.png](img/factorymethod.png)

Struktura klas i obiektów:
- Produkt (Page) - definiuje abstrakcyjną klasę obiektów, które tworzy fabryka
- ConcreteProduct (SkillsPage, EducationPage, ExperiencePage) - implementuje abstrakcyjną klasę  Product
- Creator (Document) - deklaruje metodę fabryczną, która zwraca obiekt typu Product. Twórca może również zdefiniować domyślną implementację metody factory, która zwraca domyślny obiekt ConcreteProduct. Może wywołać metodę factory w celu utworzenia obiektu typu Product.
- ConcreteCreator (Raport, Resume) - zastępuje metodę factory, aby zwrócić instancję obiektu ConcreteProduct.

```cs

using System.Collections.Generic;

class Program
{
    static void Main()
    {
        // Note: constructors call Factory Method
        Document[] documents = new Document[2];
        documents[0] = new Resume();
        documents[1] = new Report();
        // Display document pages
        foreach (Document document in documents)
        {
            Console.WriteLine("\n" + document.GetType().Name + "--");
            foreach (Page page in document.Pages)
            {
                Console.WriteLine(" " + page.GetType().Name);
            }
        }
    }
}
// The 'Product' abstract class
abstract class Page {}
// A 'ConcreteProduct' class
class SkillsPage : Page {}
// A 'ConcreteProduct' class
class EducationPage : Page {}
// A 'ConcreteProduct' class
class ExperiencePage : Page {}
// A 'ConcreteProduct' class
class IntroductionPage : Page {}
// A 'ConcreteProduct' class
class ResultsPage : Page {}
// A 'ConcreteProduct' class
class ConclusionPage : Page {}
// A 'ConcreteProduct' class
// </summary>
class SummaryPage : Page {}
// A 'ConcreteProduct' class
class BibliographyPage : Page {}
// The 'Creator' abstract class
abstract class Document
{
    private List<Page> _pages = new List<Page>();
    // Constructor calls abstract Factory method
    public Document()
    {
        this.CreatePages();
    }
    public List<Page> Pages
    {
        get { return _pages; }
    }
    // Factory Method
    public abstract void CreatePages();
}
// A 'ConcreteCreator' class
class Resume : Document
{
    // Factory Method implementation
    public override void CreatePages()
    {
        Pages.Add(new SkillsPage());
        Pages.Add(new EducationPage());
        Pages.Add(new ExperiencePage());
    }
}
// A 'ConcreteCreator' class
class Report : Document
{
    // Factory Method implementation
    public override void CreatePages()
    {
        Pages.Add(new IntroductionPage());
        Pages.Add(new ResultsPage());
        Pages.Add(new ConclusionPage());
        Pages.Add(new SummaryPage());
        Pages.Add(new BibliographyPage());
    }
}


```

#### Prototype

Wzorzec projektowy Prototype określa obiekty, które można tworzyć za pomocą prototypowej instancji, i tworzyć nowe obiekty poprzez kopiowanie tego prototypu.

![prototype.png](img/prototype.png)

Struktura klas i obiektów:
- Prototyp (ColorPrototype) - deklaruje abstrakcyjną klasę do klonowania swoich pól
- ConcretePrototype (Color) - implementuje operację klonowania swoich pól
- Klient (ColorManager) - tworzy nowy obiekt oraz uruchamia metodę klonowania prototypu

```cs

public class Program
{
    public static void Main(string[] args)
    {
        ColorManager colormanager = new ColorManager();
        // Initialize with standard colors
        colormanager["red"] = new Color(255, 0, 0);
        colormanager["green"] = new Color(0, 255, 0);
        colormanager["blue"] = new Color(0, 0, 255);
        // User adds personalized colors
        colormanager["angry"] = new Color(255, 54, 0);
        colormanager["peace"] = new Color(128, 211, 128);
        colormanager["flame"] = new Color(211, 34, 20);
        // User clones selected colors
        Color color1 = colormanager["red"].Clone() as Color;
        Color color2 = colormanager["peace"].Clone() as Color;
        Color color3 = colormanager["flame"].Clone() as Color;
    }
}
// The 'Prototype' abstract class
public abstract class ColorPrototype
{
    public abstract ColorPrototype Clone();
}
// The 'ConcretePrototype' class
public class Color : ColorPrototype
{
    int red;
    int green;
    int blue;
    // Constructor
    public Color(int red, int green, int blue)
    {
        this.red = red;
        this.green = green;
        this.blue = blue;
    }
    // Create a shallow copy
    public override ColorPrototype Clone()
    {
        Console.WriteLine(
            "Cloning color RGB: {0,3},{1,3},{2,3}",
            red, green, blue);
        return this.MemberwiseClone() as ColorPrototype;
    }
}
// Prototype manager
public class ColorManager
{
    private Dictionary<string, ColorPrototype> colors =
        new Dictionary<string, ColorPrototype>();
    // Indexer
    public ColorPrototype this[string key]
    {
        get { return colors[key]; }
        set { colors.Add(key, value); }
    }
}

```

#### Singleton

Wzorzec projektowy Singleton zapewnia, że klasa ma tylko jedną instancję i zapewnia globalny punkt dostępu do niej.

![Singleton.png](img/Singleton.png)

Struktura klas i obiektów:
- Singleton (LoadBalancer) - definiuje metodę Instance, która pozwala klientom na dostęp do jej unikalnej instancji.

```cs

public class Program
{
    public static void Main(string[] args)
    {
        LoadBalancer b1 = LoadBalancer.GetLoadBalancer();
        LoadBalancer b2 = LoadBalancer.GetLoadBalancer();
        LoadBalancer b3 = LoadBalancer.GetLoadBalancer();
        LoadBalancer b4 = LoadBalancer.GetLoadBalancer();
        // Same instance?
        if (b1 == b2 && b2 == b3 && b3 == b4)
        {
            Console.WriteLine("Same instance\n");
        }
        // Load balance 15 server requests
        LoadBalancer balancer = LoadBalancer.GetLoadBalancer();
        for (int i = 0; i < 15; i++)
        {
            string server = balancer.Server;
            Console.WriteLine("Dispatch Request to: " + server);
        }
    }
}
// The 'Singleton' class
public class LoadBalancer
{
    static LoadBalancer instance;
    List<string> servers = new List<string>();
    Random random = new Random();
    // Lock synchronization object
    private static object locker = new object();
    // Constructor (protected)
    protected LoadBalancer()
    {
        // List of available servers
        servers.Add("ServerI");
        servers.Add("ServerII");
        servers.Add("ServerIII");
        servers.Add("ServerIV");
        servers.Add("ServerV");
    }
    public static LoadBalancer GetLoadBalancer()
    {
        // Support multithreaded applications through
        // 'Double checked locking' pattern which (once
        // the instance exists) avoids locking each
        // time the method is invoked
        if (instance == null)
        {
            lock (locker)
            {
                if (instance == null)
                {
                    instance = new LoadBalancer();
                }
            }
        }
        return instance;
    }
    // Simple, but effective random load balancer
    public string Server
    {
        get
        {
            int r = random.Next(servers.Count);
            return servers[r].ToString();
        }
    }
}

```

### Structural Patterns

#### Adapter

Wzorzec projektowy Adapter konwertuje interfejs klasy na inny interfejs, którego oczekują klienci. Ten wzorzec projektowy pozwala na współpracę klas, które w przeciwnym razie nie mogłyby współpracować ze względu na niekompatybilne interfejsy.

![adapter.png](img/adapter.png)

Struktura klas i obiektów:
- Target (ChemicalCompound) - definiuje specyficzny zestaw metod, z którego korzysta Klient.
- Adapter (Compound) - dostosowuje zestaw metod Adaptee do zestawu metod Target.
- Adaptee (ChemicalDatabank) - definiuje istniejący zestaw metod, który wymaga adaptacji.

```cs

public class Program
{
    public static void Main(string[] args)
    {
        // Non-adapted chemical compound
        Compound unknown = new Compound();
        unknown.Display();
        // Adapted chemical compounds
        Compound water = new RichCompound("Water");
        water.Display();
        Compound benzene = new RichCompound("Benzene");
        benzene.Display();
        Compound ethanol = new RichCompound("Ethanol");
        ethanol.Display();
    }
}
// The 'Target' class
public class Compound
{
    protected float boilingPoint;
    protected float meltingPoint;
    protected double molecularWeight;
    protected string molecularFormula;
    public virtual void Display()
    {
        Console.WriteLine("\nCompound: Unknown ------ ");
    }
}
// The 'Adapter' class
public class RichCompound : Compound
{
    private string chemical;
    private ChemicalDatabank bank;
    // Constructor
    public RichCompound(string chemical)
    {
        this.chemical = chemical;
    }
    public override void Display()
    {
        // The Adaptee
        bank = new ChemicalDatabank();
        boilingPoint = bank.GetCriticalPoint(chemical, "B");
        meltingPoint = bank.GetCriticalPoint(chemical, "M");
        molecularWeight = bank.GetMolecularWeight(chemical);
        molecularFormula = bank.GetMolecularStructure(chemical);
        Console.WriteLine("\nCompound: {0} ------ ", chemical);
        Console.WriteLine(" Formula: {0}", molecularFormula);
        Console.WriteLine(" Weight : {0}", molecularWeight);
        Console.WriteLine(" Melting Pt: {0}", meltingPoint);
        Console.WriteLine(" Boiling Pt: {0}", boilingPoint);
    }
}
// The 'Adaptee' class
public class ChemicalDatabank
{
    // The databank 'legacy API'
    public float GetCriticalPoint(string compound, string point)
    {
        // Melting Point
        if (point == "M")
        {
            switch (compound.ToLower())
            {
                case "water": return 0.0f;
                case "benzene": return 5.5f;
                case "ethanol": return -114.1f;
                default: return 0f;
            }
        }
        // Boiling Point
        else
        {
            switch (compound.ToLower())
            {
                case "water": return 100.0f;
                case "benzene": return 80.1f;
                case "ethanol": return 78.3f;
                default: return 0f;
            }
        }
    }
    public string GetMolecularStructure(string compound)
    {
        switch (compound.ToLower())
        {
            case "water": return "H20";
            case "benzene": return "C6H6";
            case "ethanol": return "C2H5OH";
            default: return "";
        }
    }
    public double GetMolecularWeight(string compound)
    {
        switch (compound.ToLower())
        {
            case "water": return 18.015;
            case "benzene": return 78.1134;
            case "ethanol": return 46.0688;
            default: return 0d;
        }
    }
}

```

#### Bridge

Wzorzec projektowy Bridge odłącza abstrakcję od jej implementacji, dzięki czemu obie mogą się zmieniać niezależnie.

![bridge.png](img/bridge.png)

Struktura klas i obiektów:
- Abstrakcja (BusinessObject) - definiuje zestaw metod abstrakcji, utrzymuje referencję do obiektu typu Implementor.
- RefinedAbstraction (CustomersBusinessObject) - rozszerza zestaw metod zdefiniowany przez Abstraction.
- Implementor (DataObject) - definiuje interfejs dla klas implementujących. Ten interfejs nie musi dokładnie odpowiadać interfejsowi Abstrakcji; w rzeczywistości te dwa interfejsy mogą być całkiem różne. Zazwyczaj interfejs Implementation zapewnia tylko prymitywne operacje, a Abstraction definiuje operacje wyższego poziomu oparte na tych prymitywach.
- ConcreteImplementor (CustomersDataObject) - implementuje metody Implementor.

```cs

public class Program
{
    public static void Main(string[] args)
    {
        // Create RefinedAbstraction
        var customers = new Customers();
        // Set ConcreteImplementor
        customers.Data = new CustomersData("Chicago");
        // Exercise the bridge
        customers.Show();
        customers.Next();
        customers.Show();
        customers.Next();
        customers.Show();
        customers.Add("Henry Velasquez");
        customers.ShowAll();
    }
}
// The 'Abstraction' class
public class CustomersBase
{
    private DataObject dataObject;
    public DataObject Data
    {
        set { dataObject = value; }
        get { return dataObject; }
    }
    public virtual void Next()
    {
        dataObject.NextRecord();
    }
    public virtual void Prior()
    {
        dataObject.PriorRecord();
    }
    public virtual void Add(string customer)
    {
        dataObject.AddRecord(customer);
    }
    public virtual void Delete(string customer)
    {
        dataObject.DeleteRecord(customer);
    }
    public virtual void Show()
    {
        dataObject.ShowRecord();
    }
    public virtual void ShowAll()
    {
        dataObject.ShowAllRecords();
    }
}
// The 'RefinedAbstraction' class
public class Customers : CustomersBase
{
    public override void ShowAll()
    {
        // Add separator lines
        Console.WriteLine();
        Console.WriteLine("------------------------");
        base.ShowAll();
        Console.WriteLine("------------------------");
    }
}
// The 'Implementor' abstract class
public abstract class DataObject
{
    public abstract void NextRecord();
    public abstract void PriorRecord();
    public abstract void AddRecord(string name);
    public abstract void DeleteRecord(string name);
    public abstract string GetCurrentRecord();
    public abstract void ShowRecord();
    public abstract void ShowAllRecords();
}
// The 'ConcreteImplementor' class
public class CustomersData : DataObject
{
    private readonly List<string> customers = new List<string>();
    private int current = 0;
    private string city;
    public CustomersData(string city)
    {
        this.city = city;
        // Loaded from a database 
        customers.Add("Jim Jones");
        customers.Add("Samual Jackson");
        customers.Add("Allen Good");
        customers.Add("Ann Stills");
        customers.Add("Lisa Giolani");
    }
    public override void NextRecord()
    {
        if (current <= customers.Count - 1)
        {
            current++;
        }
    }
    public override void PriorRecord()
    {
        if (current > 0)
        {
            current--;
        }
    }
    public override void AddRecord(string customer)
    {
        customers.Add(customer);
    }
    public override void DeleteRecord(string customer)
    {
        customers.Remove(customer);
    }
    public override string GetCurrentRecord()
    {
        return customers[current];
    }
    public override void ShowRecord()
    {
        Console.WriteLine(customers[current]);
    }
    public override void ShowAllRecords()
    {
        Console.WriteLine("Customer City: " + city);
        foreach (string customer in customers)
        {
            Console.WriteLine(" " + customer);
        }
    }
}

```

#### Composite 

Wzorzec projektowy Composite składa obiekty w struktury drzewiaste w celu reprezentowania hierarchii część-całość. Ten wzorzec pozwala klientom traktować pojedyncze obiekty i kompozycje obiektów w sposób jednolity.

![composite.png](img/composite.png)

Struktura klas i obiektów:
- Component (DrawingElement) - deklaruje metody dla obiektów w kompozycji. Implementuje domyślne zachowanie dla metod wspólnych dla wszystkich klas. Deklaruje metody dostępu i zarządzania do komponentów "dzieci".
- Liść (PrimitiveElement) - reprezentuje obiekty liści w kompozycji. Liść nie posiada dzieci. Definiuje zachowanie dla obiektów prymitywnych w kompozycji.
- Composite (CompositeElement) - definiuje zachowanie dla komponentów posiadających dzieci Przechowuje komponenty potomne. Implementuje operacje związane z dziećmi w interfejsie Component.

```cs

public class Program
{
    public static void Main(string[] args)
    {
        // Create a tree structure 
        CompositeElement root = new CompositeElement("Picture");
        root.Add(new PrimitiveElement("Red Line"));
        root.Add(new PrimitiveElement("Blue Circle"));
        root.Add(new PrimitiveElement("Green Box"));
        // Create a branch
        CompositeElement comp = new CompositeElement("Two Circles");
        comp.Add(new PrimitiveElement("Black Circle"));
        comp.Add(new PrimitiveElement("White Circle"));
        root.Add(comp);
        // Add and remove a PrimitiveElement
        PrimitiveElement pe = new PrimitiveElement("Yellow Line");
        root.Add(pe);
        root.Remove(pe);
        // Recursively display nodes
        root.Display(1);
    }
}
// The 'Component' Treenode
public abstract class DrawingElement
{
    protected string name;
    // Constructor
    public DrawingElement(string name)
    {
        this.name = name;
    }
    public abstract void Add(DrawingElement d);
    public abstract void Remove(DrawingElement d);
    public abstract void Display(int indent);
}
// The 'Leaf' class
public class PrimitiveElement : DrawingElement
{
    // Constructor
    public PrimitiveElement(string name)
        : base(name)
    {
    }
    public override void Add(DrawingElement c)
    {
        Console.WriteLine(
            "Cannot add to a PrimitiveElement");
    }
    public override void Remove(DrawingElement c)
    {
        Console.WriteLine(
            "Cannot remove from a PrimitiveElement");
    }
    public override void Display(int indent)
    {
        Console.WriteLine(
            new String('-', indent) + " " + name);
    }
}
// The 'Composite' class
public class CompositeElement : DrawingElement
{
    List<DrawingElement> elements = new List<DrawingElement>();
    // Constructor
    public CompositeElement(string name)
        : base(name)
    {
    }
    public override void Add(DrawingElement d)
    {
        elements.Add(d);
    }
    public override void Remove(DrawingElement d)
    {
        elements.Remove(d);
    }
    public override void Display(int indent)
    {
        Console.WriteLine(new String('-', indent) +
            "+ " + name);
        // Display each child element on this node
        foreach (DrawingElement d in elements)
        {
            d.Display(indent + 2);
        }
    }
}

```

#### Decorator 	

Wzorzec projektowy Decorator dołącza do obiektu dodatkowe metody. Wzorzec ten stanowi elastyczną alternatywę dla podklas w celu rozszerzenia funkcjonalności.

![decorator.png](img/decorator.png)

Struktura klas i obiektów:
- Component (LibraryItem) - definiuje zestaw metod dla obiektów, które mogą mieć dynamicznie dodawane metody.
- ConcreteComponent (Book, Video) - definiuje obiekt, do którego można dołączyć dodatkowe metody.
- Dekorator (Decorator) - utrzymuje referencję do obiektu Component i definiuje metody zgodny z abstrakcjami Component.
- ConcreteDecorator (Borrowable) - dodaje metody do komponentu.

```cs

public class Program
{
    public static void Main(string[] args)
    {
        // Create book
        Book book = new Book("Worley", "Inside ASP.NET", 10);
        book.Display();
        // Create video
        Video video = new Video("Spielberg", "Jaws", 23, 92);
        video.Display();
        // Make video borrowable, then borrow and display
        Console.WriteLine("\nMaking video borrowable:");
        Borrowable borrowvideo = new Borrowable(video);
        borrowvideo.BorrowItem("Customer #1");
        borrowvideo.BorrowItem("Customer #2");
        borrowvideo.Display();
    }
}
// The 'Component' abstract class
public abstract class LibraryItem
{
    private int numCopies;
    public int NumCopies
    {
        get { return numCopies; }
        set { numCopies = value; }
    }
    public abstract void Display();
}
// The 'ConcreteComponent' class
public class Book : LibraryItem
{
    private string author;
    private string title;
    // Constructor
    public Book(string author, string title, int numCopies)
    {
        this.author = author;
        this.title = title;
        this.NumCopies = numCopies;
    }
    public override void Display()
    {
        Console.WriteLine("\nBook ------ ");
        Console.WriteLine(" Author: {0}", author);
        Console.WriteLine(" Title: {0}", title);
        Console.WriteLine(" # Copies: {0}", NumCopies);
    }
}
// The 'ConcreteComponent' class
public class Video : LibraryItem
{
    private string director;
    private string title;
    private int playTime;
    // Constructor
    public Video(string director, string title, int numCopies, int playTime)
    {
        this.director = director;
        this.title = title;
        this.NumCopies = numCopies;
        this.playTime = playTime;
    }
    public override void Display()
    {
        Console.WriteLine("\nVideo ----- ");
        Console.WriteLine(" Director: {0}", director);
        Console.WriteLine(" Title: {0}", title);
        Console.WriteLine(" # Copies: {0}", NumCopies);
        Console.WriteLine(" Playtime: {0}\n", playTime);
    }
}
// The 'Decorator' abstract class
public abstract class Decorator : LibraryItem
{
    protected LibraryItem libraryItem;
    // Constructor
    public Decorator(LibraryItem libraryItem)
    {
        this.libraryItem = libraryItem;
    }
    public override void Display()
    {
        libraryItem.Display();
    }
}
// The 'ConcreteDecorator' class
public class Borrowable : Decorator
{
    protected readonly List<string> borrowers = new List<string>();
    // Constructor
    public Borrowable(LibraryItem libraryItem)
        : base(libraryItem)
    {
    }
    public void BorrowItem(string name)
    {
        borrowers.Add(name);
        libraryItem.NumCopies--;
    }
    public void ReturnItem(string name)
    {
        borrowers.Remove(name);
        libraryItem.NumCopies++;
    }
    public override void Display()
    {
        base.Display();
        foreach (string borrower in borrowers)
        {
            Console.WriteLine(" borrower: " + borrower);
        }
    }
}

```

#### Fasada (facade)

Wzorzec projektowy fasady zapewnia ujednolicony sposób dostępu do zestawu metod w podsystemie. Wzorzec ten definiuje zestaw metod wyższego poziomu, który ułatwia korzystanie z podsystemu.

![facade.png](img/facade.png)

Struktura klas i obiektów:
- Fasada (MortgageApplication) - wie, które klasy podsystemów są odpowiedzialne za dane żądanie. Deleguje żądania klienta do odpowiednich obiektów podsystemu.
- Klasy podsystemów (Bank, Kredyt, Pożyczka) - implementują funkcjonalność podsystemu. Wykonują pracę przydzieloną przez obiekt Fasady. Nie posiadają wiedzy o fasadzie i nie przechowują żadnych odniesień do niej.

```cs

public class Program
{
    public static void Main(string[] args)
    {
        // Facade
        Mortgage mortgage = new Mortgage();
        // Evaluate mortgage eligibility for customer
        Customer customer = new Customer("Ann McKinsey");
        bool eligible = mortgage.IsEligible(customer, 125000);
        Console.WriteLine("\n" + customer.Name +
                " has been " + (eligible ? "Approved" : "Rejected"));
    }
}
// The 'Subsystem ClassA' class
public class Bank
{
    public bool HasSufficientSavings(Customer c, int amount)
    {
        Console.WriteLine("Check bank for " + c.Name);
        return true;
    }
}
// The 'Subsystem ClassB' class
public class Credit
{
    public bool HasGoodCredit(Customer c)
    {
        Console.WriteLine("Check credit for " + c.Name);
        return true;
    }
}
// The 'Subsystem ClassC' class
public class Loan
{
    public bool HasNoBadLoans(Customer c)
    {
        Console.WriteLine("Check loans for " + c.Name);
        return true;
    }
}
// Customer class
public class Customer
{
    private string name;
    // Constructor
    public Customer(string name)
    {
        this.name = name;
    }
    public string Name
    {
        get { return name; }
    }
}
// The 'Facade' class
public class Mortgage
{
    Bank bank = new Bank();
    Loan loan = new Loan();
    Credit credit = new Credit();
    public bool IsEligible(Customer cust, int amount)
    {
        Console.WriteLine("{0} applies for {1:C} loan\n",
            cust.Name, amount);
        bool eligible = true;
        // Check creditworthyness of applicant
        if (!bank.HasSufficientSavings(cust, amount))
        {
            eligible = false;
        }
        else if (!loan.HasNoBadLoans(cust))
        {
            eligible = false;
        }
        else if (!credit.HasGoodCredit(cust))
        {
            eligible = false;
        }
        return eligible;
    }
}

```

#### Flyweight 

Wzorzec projektowy Flyweight wykorzystuje współdzielenie do efektywnej obsługi dużej liczby obiektów drobnoziarnistych.

![flyweight.png](img/flyweight.png)

Struktura klas i obiektów:
- Flyweight (Character) - deklaruje zestaw metod, poprzez który flyweights mogą otrzymywać i działać na stan zewnętrzny.
- ConcreteFlyweight (CharacterA, CharacterB, ..., CharacterZ) - implementuje zestaw metod Flyweight i dodaje przechowywanie stanu wewnętrznego, jeśli taki istnieje. Obiekt ConcreteFlyweight musi być współdzielony. Każdy stan, który przechowuje, musi być wewnętrznym, to znaczy musi być niezależny od kontekstu obiektu ConcreteFlyweight.
- UnsharedConcreteFlyweight (nie używany w poniższym przykładzie) - nie wszystkie podklasy Flyweight muszą być współdzielone. Abstrakcja Flyweight umożliwia współdzielenie, ale nie wymusza go. Powszechne jest, że obiekty UnsharedConcreteFlyweight mają obiekty ConcreteFlyweight jako dzieci na pewnym poziomie w strukturze obiektów Flyweight (tak jak mają klasy Row i Column).
- FlyweightFactory (CharacterFactory) - tworzy i zarządza obiektami flyweight oraz zapewnia, że flyweight są prawidłowo udostępniane.

Poniższy kod demonstruje wzorzec Flyweight, w którym stosunkowo niewielka liczba obiektów Character jest wielokrotnie współdzielona przez dokument, który ma potencjalnie wiele znaków.

```cs

public class Program
{
    public static void Main(string[] args)
    {
        // Build a document with text
        string document = "AAZZBBZB";
        char[] chars = document.ToCharArray();
        CharacterFactory factory = new CharacterFactory();
        // extrinsic state
        int pointSize = 10;
        // For each character use a flyweight object
        foreach (char c in chars)
        {
            pointSize++;
            Character character = factory.GetCharacter(c);
            character.Display(pointSize);
        }
    }
}
// The 'FlyweightFactory' class
public class CharacterFactory
{
    private Dictionary<char, Character> characters = new Dictionary<char, Character>();
    public Character GetCharacter(char key)
    {
        // Uses "lazy initialization"
        Character character = null;
        if (characters.ContainsKey(key))
        {
            character = characters[key];
        }
        else
        {
            switch (key)
            {
                case 'A': character = new CharacterA(); break;
                case 'B': character = new CharacterB(); break;
                //...
                case 'Z': character = new CharacterZ(); break;
            }
            characters.Add(key, character);
        }
        return character;
    }
}
// The 'Flyweight' abstract class
public abstract class Character
{
    protected char symbol;
    protected int width;
    protected int height;
    protected int ascent;
    protected int descent;
    protected int pointSize;
    public abstract void Display(int pointSize);
}
// A 'ConcreteFlyweight' class
public class CharacterA : Character
{
    // Constructor
    public CharacterA()
    {
        symbol = 'A';
        height = 100;
        width = 120;
        ascent = 70;
        descent = 0;
    }
    public override void Display(int pointSize)
    {
        this.pointSize = pointSize;
        Console.WriteLine(symbol +
            " (pointsize " + this.pointSize + ")");
    }
}
// A 'ConcreteFlyweight' class
public class CharacterB : Character
{
    // Constructor
    public CharacterB()
    {
        symbol = 'B';
        height = 100;
        width = 140;
        ascent = 72;
        descent = 0;
    }
    public override void Display(int pointSize)
    {
        this.pointSize = pointSize;
        Console.WriteLine(this.symbol +
            " (pointsize " + this.pointSize + ")");
    }
}
// ... C, D, E, etc.
/// A 'ConcreteFlyweight' class
public class CharacterZ : Character
{
    // Constructor
    public CharacterZ()
    {
        symbol = 'Z';
        height = 100;
        width = 100;
        ascent = 68;
        descent = 0;
    }
    public override void Display(int pointSize)
    {
        this.pointSize = pointSize;
        Console.WriteLine(this.symbol +
            " (pointsize " + this.pointSize + ")");
    }
}

```

#### Proxy 

Wzorzec projektowy Proxy zapewnia obiekt pośredniczący dla innego obiektu, aby kontrolować dostęp do niego.

![proxy.png](img/proxy.png)

Struktura klas i obiektów:
- Proxy (MathProxy) - utrzymuje referencję, która pozwala proxy uzyskać dostęp do właściwego obiektu. Zapewnia zestaw metod identyczny z zestawem metod właściwego obiektu.
- Subject (IMath) - definiuje wspólny zestaw metod dla RealSubject i Proxy, tak że Proxy może być używany wszędzie tam, gdzie oczekuje się RealSubject.
- RealSubject (Math) - definiuje obiekt rzeczywisty, który reprezentuje proxy.

```cs

public class Program
{
    public static void Main(string[] args)
    {
        // Create math proxy
        MathProxy proxy = new MathProxy();
        // Do the math
        Console.WriteLine("4 + 2 = " + proxy.Add(4, 2));
        Console.WriteLine("4 - 2 = " + proxy.Sub(4, 2));
        Console.WriteLine("4 * 2 = " + proxy.Mul(4, 2));
        Console.WriteLine("4 / 2 = " + proxy.Div(4, 2));
    }
}
// The 'Subject interface
public interface IMath
{
    double Add(double x, double y);
    double Sub(double x, double y);
    double Mul(double x, double y);
    double Div(double x, double y);
}
// The 'RealSubject' class
public class Math : IMath
{
    public double Add(double x, double y) { return x + y; }
    public double Sub(double x, double y) { return x - y; }
    public double Mul(double x, double y) { return x * y; }
    public double Div(double x, double y) { return x / y; }
}
// The 'Proxy Object' class
public class MathProxy : IMath
{
    private Math math = new Math();
    public double Add(double x, double y)
    {
        return math.Add(x, y);
    }
    public double Sub(double x, double y)
    {
        return math.Sub(x, y);
    }
    public double Mul(double x, double y)
    {
        return math.Mul(x, y);
    }
    public double Div(double x, double y)
    {
        return math.Div(x, y);
    }
}

```

### Behavioral Patterns

#### Chain of Responsibility

Wzorzec projektowy Chain of Responsibility pozwala uniknąć sprzężenia nadawcy żądania z jego odbiorcą, dając szansę obsługi żądania więcej niż jednemu obiektowi. Ten wzorzec tworzy łańcuchy obiektów odbierających i przekazuje żądanie wzdłuż łańcucha, dopóki jakiś obiekt go nie obsłuży.

![chain.png](img/chain.png)

Struktura klas i obiektów:
- Handler (Approver) definiuje metody wirtualnej do obsługi wniosków, opcjonalnie implementuje powiązanie następcze
- ConcreteHandler (Director, VicePresident, President) - obsługuje wnioski, za które jest odpowiedzialny, może uzyskać dostęp do swojego następcy, jeśli ConcreteHandler może obsłużyć żądanie, robi to; w przeciwnym razie przekazuje żądanie do swojego następcy

```cs

public class Program
{
    public static void Main(string[] args)
    {
        // Setup Chain of Responsibility
        Approver larry = new Director();
        Approver sam = new VicePresident();
        Approver tammy = new President();
        larry.SetSuccessor(sam);
        sam.SetSuccessor(tammy);
        // Generate and process purchase requests
        Purchase p = new Purchase(2034, 350.00, "Supplies");
        larry.ProcessRequest(p);
        p = new Purchase(2035, 32590.10, "Project X");
        larry.ProcessRequest(p);
        p = new Purchase(2036, 122100.00, "Project Y");
        larry.ProcessRequest(p);
    }
}
// The 'Handler' abstract class
public abstract class Approver
{
    protected Approver successor;
    public void SetSuccessor(Approver successor)
    {
        this.successor = successor;
    }
    public abstract void ProcessRequest(Purchase purchase);
}
// The 'ConcreteHandler' class
public class Director : Approver
{
    public override void ProcessRequest(Purchase purchase)
    {
        if (purchase.Amount < 10000.0)
        {
            Console.WriteLine("{0} approved request# {1}",
                this.GetType().Name, purchase.Number);
        }
        else if (successor != null)
        {
            successor.ProcessRequest(purchase);
        }
    }
}
// The 'ConcreteHandler' class
public class VicePresident : Approver
{
    public override void ProcessRequest(Purchase purchase)
    {
        if (purchase.Amount < 25000.0)
        {
            Console.WriteLine("{0} approved request# {1}",
                this.GetType().Name, purchase.Number);
        }
        else if (successor != null)
        {
            successor.ProcessRequest(purchase);
        }
    }
}
// The 'ConcreteHandler' class
public class President : Approver
{
    public override void ProcessRequest(Purchase purchase)
    {
        if (purchase.Amount < 100000.0)
        {
            Console.WriteLine("{0} approved request# {1}",
                this.GetType().Name, purchase.Number);
        }
        else
        {
            Console.WriteLine(
                "Request# {0} requires an executive meeting!",
                purchase.Number);
        }
    }
}
// Class holding request details
public class Purchase
{
    int number;
    double amount;
    string purpose;
    // Constructor
    public Purchase(int number, double amount, string purpose)
    {
        this.number = number;
        this.amount = amount;
        this.purpose = purpose;
    }
    // Gets or sets purchase number
    public int Number
    {
        get { return number; }
        set { number = value; }
    }
    // Gets or sets purchase amount
    public double Amount
    {
        get { return amount; }
        set { amount = value; }
    }
    // Gets or sets purchase purpose
    public string Purpose
    {
        get { return purpose; }
        set { purpose = value; }
    }
}

```


#### Command 	

Wzorzec projektowy Command hermetyzuje żądanie jako obiekt, pozwalając tym samym na sparametryzowanie klientów z różnymi żądaniami, kolejkowanie lub rejestrowanie żądań oraz obsługę operacji cofania.

![command.png](img/command.png)

Struktura klas i obiektów:
- Polecenie (Command) - deklaruje abstrakcyjne metody do wykonania operacji
- ConcreteCommand (CalculatorCommand) - definiuje wiązanie pomiędzy obiektem Receiver a akcją implementuje Execute poprzez wywołanie odpowiedniej operacji na Receiver
- Klient (CommandApp) - tworzy obiekt ConcreteCommand i ustawia jego Receiver
- Invoker (Użytkownik) - prosi polecenie o wykonanie żądania
- Receiver (Calculator) - wie, jak wykonać operacje związane z realizacją żądania.

```cs

public class Program
{
    public static void Main(string[] args)
    {
        // Create user and let her compute
        User user = new User();
        // User presses calculator buttons
        user.Compute('+', 100);
        user.Compute('-', 50);
        user.Compute('*', 10);
        user.Compute('/', 2);
        // Undo 4 commands
        user.Undo(4);
        // Redo 3 commands
        user.Redo(3);
    }
}
// The 'Command' abstract class
public abstract class Command
{
    public abstract void Execute();
    public abstract void UnExecute();
}
// The 'ConcreteCommand' class
public class CalculatorCommand : Command
{
    char @operator;
    int operand;
    Calculator calculator;
    // Constructor
    public CalculatorCommand(Calculator calculator,
        char @operator, int operand)
    {
        this.calculator = calculator;
        this.@operator = @operator;
        this.operand = operand;
    }
    // Gets operator
    public char Operator
    {
        set { @operator = value; }
    }
    // Get operand
    public int Operand
    {
        set { operand = value; }
    }
    // Execute new command
    public override void Execute()
    {
        calculator.Operation(@operator, operand);
    }
    // Unexecute last command
    public override void UnExecute()
    {
        calculator.Operation(Undo(@operator), operand);
    }
    // Returns opposite operator for given operator
    private char Undo(char @operator)
    {
        switch (@operator)
        {
            case '+': return '-';
            case '-': return '+';
            case '*': return '/';
            case '/': return '*';
            default:
                throw new
            ArgumentException("@operator");
        }
    }
}
// The 'Receiver' class
public class Calculator
{
    int curr = 0;
    public void Operation(char @operator, int operand)
    {
        switch (@operator)
        {
            case '+': curr += operand; break;
            case '-': curr -= operand; break;
            case '*': curr *= operand; break;
            case '/': curr /= operand; break;
        }
        Console.WriteLine(
            "Current value = {0,3} (following {1} {2})",
            curr, @operator, operand);
    }
}
// The 'Invoker' class
public class User
{
    // Initializers
    Calculator calculator = new Calculator();
    List<Command> commands = new List<Command>();
    int current = 0;
    public void Redo(int levels)
    {
        Console.WriteLine("\n---- Redo {0} levels ", levels);
        // Perform redo operations
        for (int i = 0; i < levels; i++)
        {
            if (current < commands.Count - 1)
            {
                Command command = commands[current++];
                command.Execute();
            }
        }
    }
    public void Undo(int levels)
    {
        Console.WriteLine("\n---- Undo {0} levels ", levels);
        
        // Perform undo operations
        for (int i = 0; i < levels; i++)
        {
            if (current > 0)
            {
                Command command = commands[--current] as Command;
                command.UnExecute();
            }
        }
    }
    public void Compute(char @operator, int operand)
    {
        // Create command operation and execute it
        Command command = new CalculatorCommand(calculator, @operator, operand);
        command.Execute();
        // Add command to undo list
        commands.Add(command);
        current++;
    }
}

```

#### Interpreter 	

Biorąc pod uwagę język, wzór projektowy Interpreter definiuje reprezentację dla jego gramatyki wraz z interpreterem, który używa reprezentacji do interpretacji zdań w języku.

![interpreter.png](img/interpreter.png)

Struktura klas i obiektów:
- AbstractExpression (Expression) deklaruje zestaw abstrakyjnych metod do wykonania operacji
- TerminalExpression (ThousandExpression, HundredExpression, TenExpression, OneExpression) - implementuje operację Interpretuj związaną z symbolami terminalnymi w gramatyce. Instancja jest wymagana dla każdego symbolu terminalnego w zdaniu.
- NonterminalExpression (nieużywany w poniższym przykładzie) - jedna taka klasa jest wymagana dla każdej reguły R ::= R1R2...Rn w gramatyce utrzymuje zmienne instancji typu AbstractExpression dla każdego z symboli od R1 do Rn. Implementuje operację Interpret dla symboli nieterminalnych w gramatyce. Interpret zazwyczaj wywołuje siebie rekurencyjnie na zmiennych reprezentujących R1 do Rn.
- Kontekst (Context) - zawiera informacje, które są globalne dla tłumacza

```cs

public class Program
{
    public static void Main(string[] args)
    {
        string roman = "MCMXXVIII";
        Context context = new Context(roman);
        // Build the 'parse tree'
        List<Expression> tree = new List<Expression>();
        tree.Add(new ThousandExpression());
        tree.Add(new HundredExpression());
        tree.Add(new TenExpression());
        tree.Add(new OneExpression());
        // Interpret
        foreach (Expression exp in tree)
        {
            exp.Interpret(context);
        }
        Console.WriteLine("{0} = {1}",
            roman, context.Output);
    }
}
// The 'Context' class
public class Context
{
    string input;
    int output;
    // Constructor
    public Context(string input)
    {
        this.input = input;
    }
    public string Input
    {
        get { return input; }
        set { input = value; }
    }
    public int Output
    {
        get { return output; }
        set { output = value; }
    }
}
// The 'AbstractExpression' class
public abstract class Expression
{
    public void Interpret(Context context)
    {
        if (context.Input.Length == 0)
            return;
        if (context.Input.StartsWith(Nine()))
        {
            context.Output += (9 * Multiplier());
            context.Input = context.Input.Substring(2);
        }
        else if (context.Input.StartsWith(Four()))
        {
            context.Output += (4 * Multiplier());
            context.Input = context.Input.Substring(2);
        }
        else if (context.Input.StartsWith(Five()))
        {
            context.Output += (5 * Multiplier());
            context.Input = context.Input.Substring(1);
        }
        while (context.Input.StartsWith(One()))
        {
            context.Output += (1 * Multiplier());
            context.Input = context.Input.Substring(1);
        }
    }
    public abstract string One();
    public abstract string Four();
    public abstract string Five();
    public abstract string Nine();
    public abstract int Multiplier();
}
// A 'TerminalExpression' class
// Thousand checks for the Roman Numeral M 
public class ThousandExpression : Expression
{
    public override string One() { return "M"; }
    public override string Four() { return " "; }
    public override string Five() { return " "; }
    public override string Nine() { return " "; }
    public override int Multiplier() { return 1000; }
}
// A 'TerminalExpression' class
// Hundred checks C, CD, D or CM
public class HundredExpression : Expression
{
    public override string One() { return "C"; }
    public override string Four() { return "CD"; }
    public override string Five() { return "D"; }
    public override string Nine() { return "CM"; }
    public override int Multiplier() { return 100; }
}
// A 'TerminalExpression' class
// Ten checks for X, XL, L and XC
public class TenExpression : Expression
{
    public override string One() { return "X"; }
    public override string Four() { return "XL"; }
    public override string Five() { return "L"; }
    public override string Nine() { return "XC"; }
    public override int Multiplier() { return 10; }
}
// A 'TerminalExpression' class
// One checks for I, II, III, IV, V, VI, VI, VII, VIII, IX
public class OneExpression : Expression
{
    public override string One() { return "I"; }
    public override string Four() { return "IV"; }
    public override string Five() { return "V"; }
    public override string Nine() { return "IX"; }
    public override int Multiplier() { return 1; }
}

```

#### Iterator

Wzorzec projektowy Iterator zapewnia sposób sekwencyjnego dostępu do elementów obiektu zagregowanego bez eksponowania jego podstawowej reprezentacji.

![iterator.png](img/iterator.png)

Struktura klas i obiektów:
- Iterator (AbstractIterator) - definiuje zestaw abstrakyjnyh metod dostępu do elementów i ich przemierzania.
- ConcreteIterator (Iterator) - implementuje Iterator. Śledzi bieżącą pozycję w ramach iterowanego obiektu.
- Aggregate (AbstractCollection) - definiuje zestaw abstrakcyjnych metod do tworzenia obiektu Iteratora
- ConcreteAggregate (Collection) - implementuje AbstractCollection, aby zwrócić instancję właściwego ConcreteIteratora

```cs

public class Program
{
    public static void Main(string[] args)
    {
        // Build a collection
        Collection collection = new Collection();
        collection[0] = new Item("Item 0");
        collection[1] = new Item("Item 1");
        collection[2] = new Item("Item 2");
        collection[3] = new Item("Item 3");
        collection[4] = new Item("Item 4");
        collection[5] = new Item("Item 5");
        collection[6] = new Item("Item 6");
        collection[7] = new Item("Item 7");
        collection[8] = new Item("Item 8");
        // Create iterator
        Iterator iterator = collection.CreateIterator();
        // Skip every other item
        iterator.Step = 2;
        Console.WriteLine("Iterating over collection:");
        for (Item item = iterator.First();
            !iterator.IsDone; item = iterator.Next())
        {
            Console.WriteLine(item.Name);
        }
    }
}
// A collection item
public class Item
{
    string name;
    // Constructor
    public Item(string name)
    {
        this.name = name;
    }
    public string Name
    {
        get { return name; }
    }
}
// The 'Aggregate' interface
public interface IAbstractCollection
{
    Iterator CreateIterator();
}
// The 'ConcreteAggregate' class
public class Collection : IAbstractCollection
{
    List<Item> items = new List<Item>();
    public Iterator CreateIterator()
    {
        return new Iterator(this);
    }
    // Gets item count
    public int Count
    {
        get { return items.Count; }
    }
    // Indexer
    public Item this[int index]
    {
        get { return items[index]; }
        set { items.Add(value); }
    }
}
// The 'Iterator' interface
public interface IAbstractIterator
{
    Item First();
    Item Next();
    bool IsDone { get; }
    Item CurrentItem { get; }
}
// The 'ConcreteIterator' class
public class Iterator : IAbstractIterator
{
    Collection collection;
    int current = 0;
    int step = 1;
    // Constructor
    public Iterator(Collection collection)
    {
        this.collection = collection;
    }
    // Gets first item
    public Item First()
    {
        current = 0;
        return collection[current] as Item;
    }
    // Gets next item
    public Item Next()
    {
        current += step;
        if (!IsDone)
            return collection[current] as Item;
        else
            return null;
    }
    // Gets or sets stepsize
    public int Step
    {
        get { return step; }
        set { step = value; }
    }
    // Gets current iterator item
    public Item CurrentItem
    {
        get { return collection[current] as Item; }
    }
    // Gets whether iteration is complete
    public bool IsDone
    {
        get { return current >= collection.Count; }
    }
}


```

#### Mediator

Wzorzec projektowy Mediator definiuje obiekt, który hermetyzuje sposób interakcji zestawu obiektów. Mediator implementuje luźne sprzężenie poprzez powstrzymywanie obiektów od odwoływania się do siebie w sposób jawny i pozwala na niezależne różnicowanie ich interakcji.

![mediator.png](img/mediator.png)


Struktura klas i obiektów:
- Mediator (IChatroom) - definiuje zestaw abstrakcyjnych metod do komunikacji z obiektami Colleague
- ConcreteMediator (Chatroom) - implementuje zachowanie kooperacyjne poprzez koordynację obiektów Colleague. Zna i utrzymuje swoich kolegów
- Klasy koleżeńskie (Participant) - każda klasa koleżeńska zna swój obiekt Mediatora. Każdy kolega komunikuje się ze swoim mediatorem zawsze wtedy, gdy w przeciwnym razie komunikowałby się z innym kolegą.

```cs

public class Program
{
    public static void Main(string[] args)
    {
        // Create chatroom
        Chatroom chatroom = new Chatroom();
        // Create participants and register them
        Participant George = new Beatle("George");
        Participant Paul = new Beatle("Paul");
        Participant Ringo = new Beatle("Ringo");
        Participant John = new Beatle("John");
        Participant Yoko = new NonBeatle("Yoko");
        chatroom.Register(George);
        chatroom.Register(Paul);
        chatroom.Register(Ringo);
        chatroom.Register(John);
        chatroom.Register(Yoko);
        // Chatting participants
        Yoko.Send("John", "Hi John!");
        Paul.Send("Ringo", "All you need is love");
        Ringo.Send("George", "My sweet Lord");
        Paul.Send("John", "Can't buy me love");
        John.Send("Yoko", "My sweet love");
    }
}
// The 'Mediator' abstract class
public abstract class AbstractChatroom
{
    public abstract void Register(Participant participant);
    public abstract void Send(
        string from, string to, string message);
}
// The 'ConcreteMediator' class
public class Chatroom : AbstractChatroom
{
    private Dictionary<string, Participant> participants = new Dictionary<string, Participant>();
    public override void Register(Participant participant)
    {
        if (!participants.ContainsValue(participant))
        {
            participants[participant.Name] = participant;
        }
        participant.Chatroom = this;
    }
    public override void Send(string from, string to, string message)
    {
        Participant participant = participants[to];
        if (participant != null)
        {
            participant.Receive(from, message);
        }
    }
}
// The 'AbstractColleague' class
public class Participant
{
    Chatroom chatroom;
    string name;
    // Constructor
    public Participant(string name)
    {
        this.name = name;
    }
    // Gets participant name
    public string Name
    {
        get { return name; }
    }
    // Gets chatroom
    public Chatroom Chatroom
    {
        set { chatroom = value; }
        get { return chatroom; }
    }
    // Sends message to given participant
    public void Send(string to, string message)
    {
        chatroom.Send(name, to, message);
    }
    // Receives message from given participant
    public virtual void Receive(
        string from, string message)
    {
        Console.WriteLine("{0} to {1}: '{2}'",
            from, Name, message);
    }
}
// A 'ConcreteColleague' class
public class Beatle : Participant
{
    // Constructor
    public Beatle(string name)
        : base(name)
    {
    }
    public override void Receive(string from, string message)
    {
        Console.Write("To a Beatle: ");
        base.Receive(from, message);
    }
}
// A 'ConcreteColleague' class
public class NonBeatle : Participant
{
    // Constructor
    public NonBeatle(string name)
        : base(name)
    {
    }
    public override void Receive(string from, string message)
    {
        Console.Write("To a non-Beatle: ");
        base.Receive(from, message);
    }
}


```

#### Memento

Wzorzec projektowy Memento bez naruszania enkapsulacji przechwytuje i uzewnętrznia wewnętrzny stan obiektu, tak aby obiekt mógł być później przywrócony do tego stanu.

![memento.png](img/memento.png)

Struktura klas i obiektów:
- Memento (Memento) - przechowuje wewnętrzny stan obiektu Originator. Memento może przechowywać tyle stanów obiektu, ile jest potrzebne według uznania inicjatora. Chroni przed dostępem obiektów innych niż inicjator. Memento ma efektywnie dwa interfejsy. Caretaker widzi wąski interfejs do memento -- może jedynie przekazać memento do innych obiektów. Inicjator natomiast widzi szeroki interfejs, taki, który pozwala mu na dostęp do wszystkich danych niezbędnych do przywrócenia się do poprzedniego stanu. Idealnie byłoby, gdyby tylko inicjator, który wytwarza memento, miał dostęp do wewnętrznego stanu memento.
- Inicjator (SalesProspect) - tworzy memento zawierające migawkę jego aktualnego stanu wewnętrznego. Używa memento do przywrócenia swojego stanu wewnętrznego
- Opiekun (Caretaker) - jest odpowiedzialny za przechowywanie memento nigdy nie operuje na Memento ani nie bada jego zawartości.

```cs

public class Program
{
    public static void Main(string[] args)
    {
        SalesProspect s = new SalesProspect();
        s.Name = "Noel van Halen";
        s.Phone = "(412) 256-0990";
        s.Budget = 25000.0;
        // Store internal state
        ProspectMemory m = new ProspectMemory();
        m.Memento = s.SaveMemento();
        // Continue changing originator
        s.Name = "Leo Welch";
        s.Phone = "(310) 209-7111";
        s.Budget = 1000000.0;
        // Restore saved state
        s.RestoreMemento(m.Memento);
    }
}
/// <summary>
/// The 'Originator' class
/// </summary>
public class SalesProspect
{
    string name;
    string phone;
    double budget;
    // Gets or sets name
    public string Name
    {
        get { return name; }
        set
        {
            name = value;
            Console.WriteLine("Name:   " + name);
        }
    }
    // Gets or sets phone
    public string Phone
    {
        get { return phone; }
        set
        {
            phone = value;
            Console.WriteLine("Phone:  " + phone);
        }
    }
    // Gets or sets budget
    public double Budget
    {
        get { return budget; }
        set
        {
            budget = value;
            Console.WriteLine("Budget: " + budget);
        }
    }
    // Stores memento
    public Memento SaveMemento()
    {
        Console.WriteLine("\nSaving state --\n");
        return new Memento(name, phone, budget);
    }
    // Restores memento
    public void RestoreMemento(Memento memento)
    {
        Console.WriteLine("\nRestoring state --\n");
        Name = memento.Name;
        Phone = memento.Phone;
        Budget = memento.Budget;
    }
}
/// <summary>
/// The 'Memento' class
/// </summary>
public class Memento
{
    string name;
    string phone;
    double budget;
    // Constructor
    public Memento(string name, string phone, double budget)
    {
        this.name = name;
        this.phone = phone;
        this.budget = budget;
    }
    public string Name
    {
        get { return name; }
        set { name = value; }
    }
    public string Phone
    {
        get { return phone; }
        set { phone = value; }
    }
    public double Budget
    {
        get { return budget; }
        set { budget = value; }
    }
}
/// <summary>
/// The 'Caretaker' class
/// </summary>
public class ProspectMemory
{
    Memento memento;
    public Memento Memento
    {
        set { memento = value; }
        get { return memento; }
    }
}

```


#### Observer

Wzorzec projektowy Observer definiuje zależność jeden do wielu między obiektami, tak że gdy jeden obiekt zmienia stan, wszystkie jego zależności są powiadamiane i aktualizowane automatycznie.

![observer.png](img/observer.png)

Struktura klas i obiektów:
- Podmiot (Stock) - zna swoich obserwatorów. Dowolna liczba obiektów Observer może obserwować podmiot. Zapewnia zestaw abstrakcyjnych metod do dołączania i odłączania obiektów Observer.
- ConcreteSubject (IBM) - przechowuje stan interesujący dla ConcreteObserver. Wysyła powiadomienie do swoich obserwatorów, gdy jego stan się zmienia
- Observer (IInvestor) - definiuje interfejs aktualizacyjny dla obiektów, które powinny być powiadamiane o zmianach w podmiocie.
- ConcreteObserver (Investor) - utrzymuje referencję do obiektu ConcreteSubject przechowuje stan, który powinien być spójny z stanem obiektu implementuje interfejs aktualizacyjny Observer, aby zachować spójność swojego stanu z obiektem.

```cs

public class Program
{
    public static void Main(string[] args)
    {
        // Create IBM stock and attach investors
        IBM ibm = new IBM("IBM", 120.00);
        ibm.Attach(new Investor("Sorros"));
        ibm.Attach(new Investor("Berkshire"));
        // Fluctuating prices will notify investors
        ibm.Price = 120.10;
        ibm.Price = 121.00;
        ibm.Price = 120.50;
        ibm.Price = 120.75;
    }
}
/// <summary>
/// The 'Subject' abstract class
/// </summary>
public abstract class Stock
{
    private string symbol;
    private double price;
    private List<IInvestor> investors = new List<IInvestor>();
    // Constructor
    public Stock(string symbol, double price)
    {
        this.symbol = symbol;
        this.price = price;
    }
    public void Attach(IInvestor investor)
    {
        investors.Add(investor);
    }
    public void Detach(IInvestor investor)
    {
        investors.Remove(investor);
    }
    public void Notify()
    {
        foreach (IInvestor investor in investors)
        {
            investor.Update(this);
        }
        Console.WriteLine("");
    }
    // Gets or sets the price
    public double Price
    {
        get { return price; }
        set
        {
            if (price != value)
            {
                price = value;
                Notify();
            }
        }
    }
    // Gets the symbol
    public string Symbol
    {
        get { return symbol; }
    }
}
/// <summary>
/// The 'ConcreteSubject' class
/// </summary>
public class IBM : Stock
{
    // Constructor
    public IBM(string symbol, double price)
        : base(symbol, price)
    {
    }
}
/// <summary>
/// The 'Observer' interface
/// </summary>
public interface IInvestor
{
    void Update(Stock stock);
}
/// <summary>
/// The 'ConcreteObserver' class
/// </summary>
public class Investor : IInvestor
{
    private string name;
    private Stock stock;
    // Constructor
    public Investor(string name)
    {
        this.name = name;
    }
    public void Update(Stock stock)
    {
        Console.WriteLine("Notified {0} of {1}'s " +
            "change to {2:C}", name, stock.Symbol, stock.Price);
    }
    // Gets or sets the stock
    public Stock Stock
    {
        get { return stock; }
        set { stock = value; }
    }
}

```

#### State

Wzorzec projektowy State pozwala obiektowi zmienić swoje zachowanie, gdy zmienia się jego stan wewnętrzny.

![state.png](img/state.png)

Struktura klas i obiektów:
- Kontekst (Account) - definiuje zestaw abstrakcyjnych metod, którymi zainteresowani są klienci. Utrzymuje instancję podklasy ConcreteState, która definiuje aktualny stan.
- Stan (State) - definiuje zestaw abstrakcyjnych metod do enkapsulacji zachowania związanego z określonym stanem Kontekstu.
- Concrete State (RedState, SilverState, GoldState) - każda podklasa implementuje zachowanie związane ze stanem Kontekstu

```cs

public class Program
{
    public static void Main(string[] args)
    {
        // Open a new account
        Account account = new Account("Jim Johnson");
        // Apply financial transactions
        account.Deposit(500.0);
        account.Deposit(300.0);
        account.Deposit(550.0);
        account.PayInterest();
        account.Withdraw(2000.00);
        account.Withdraw(1100.00);
    }
}
// The 'State' abstract class
public abstract class State
{
    protected Account account;
    protected double balance;
    protected double interest;
    protected double lowerLimit;
    protected double upperLimit;
    // Properties
    public Account Account
    {
        get { return account; }
        set { account = value; }
    }
    public double Balance
    {
        get { return balance; }
        set { balance = value; }
    }
    public abstract void Deposit(double amount);
    public abstract void Withdraw(double amount);
    public abstract void PayInterest();
}
// A 'ConcreteState' class
// Red indicates that account is overdrawn 
public class RedState : State
{
    private double serviceFee;
    // Constructor
    public RedState(State state)
    {
        this.balance = state.Balance;
        this.account = state.Account;
        Initialize();
    }
    private void Initialize()
    {
        // Should come from a datasource
        interest = 0.0;
        lowerLimit = -100.0;
        upperLimit = 0.0;
        serviceFee = 15.00;
    }
    public override void Deposit(double amount)
    {
        balance += amount;
        StateChangeCheck();
    }
    public override void Withdraw(double amount)
    {
        amount = amount - serviceFee;
        Console.WriteLine("No funds available for withdrawal!");
    }
    public override void PayInterest()
    {
        // No interest is paid
    }
    private void StateChangeCheck()
    {
        if (balance > upperLimit)
        {
            account.State = new SilverState(this);
        }
    }
}
// A 'ConcreteState' class
// Silver indicates a non-interest bearing state
public class SilverState : State
{
    // Overloaded constructors
    public SilverState(State state) :
        this(state.Balance, state.Account)
    {
    }
    public SilverState(double balance, Account account)
    {
        this.balance = balance;
        this.account = account;
        Initialize();
    }
    private void Initialize()
    {
        // Should come from a datasource
        interest = 0.0;
        lowerLimit = 0.0;
        upperLimit = 1000.0;
    }
    public override void Deposit(double amount)
    {
        balance += amount;
        StateChangeCheck();
    }
    public override void Withdraw(double amount)
    {
        balance -= amount;
        StateChangeCheck();
    }
    public override void PayInterest()
    {
        balance += interest * balance;
        StateChangeCheck();
    }
    private void StateChangeCheck()
    {
        if (balance < lowerLimit)
        {
            account.State = new RedState(this);
        }
        else if (balance > upperLimit)
        {
            account.State = new GoldState(this);
        }
    }
}
// A 'ConcreteState' class
// Gold indicates an interest bearing state
public class GoldState : State
{
    // Overloaded constructors
    public GoldState(State state)
        : this(state.Balance, state.Account)
    {
    }
    public GoldState(double balance, Account account)
    {
        this.balance = balance;
        this.account = account;
        Initialize();
    }
    private void Initialize()
    {
        // Should come from a database
        interest = 0.05;
        lowerLimit = 1000.0;
        upperLimit = 10000000.0;
    }
    public override void Deposit(double amount)
    {
        balance += amount;
        StateChangeCheck();
    }
    public override void Withdraw(double amount)
    {
        balance -= amount;
        StateChangeCheck();
    }
    public override void PayInterest()
    {
        balance += interest * balance;
        StateChangeCheck();
    }
    private void StateChangeCheck()
    {
        if (balance < 0.0)
        {
            account.State = new RedState(this);
        }
        else if (balance < lowerLimit)
        {
            account.State = new SilverState(this);
        }
    }
}
// The 'Context' class
public class Account
{
    private State state;
    private string owner;
    // Constructor
    public Account(string owner)
    {
        // New accounts are 'Silver' by default
        this.owner = owner;
        this.state = new SilverState(0.0, this);
    }
    public double Balance
    {
        get { return state.Balance; }
    }
    public State State
    {
        get { return state; }
        set { state = value; }
    }
    public void Deposit(double amount)
    {
        state.Deposit(amount);
        Console.WriteLine("Deposited {0:C} --- ", amount);
        Console.WriteLine(" Balance = {0:C}", this.Balance);
        Console.WriteLine(" Status  = {0}",
            this.State.GetType().Name);
        Console.WriteLine("");
    }
    public void Withdraw(double amount)
    {
        state.Withdraw(amount);
        Console.WriteLine("Withdrew {0:C} --- ", amount);
        Console.WriteLine(" Balance = {0:C}", this.Balance);
        Console.WriteLine(" Status  = {0}\n",
            this.State.GetType().Name);
    }
    public void PayInterest()
    {
        state.PayInterest();
        Console.WriteLine("Interest Paid --- ");
        Console.WriteLine(" Balance = {0:C}", this.Balance);
        Console.WriteLine(" Status  = {0}\n",
            this.State.GetType().Name);
    }
}

```


#### Strategy

Wzorzec projektowy Strategy definiuje rodzinę algorytmów, hermetyzuje każdy z nich i czyni je wymiennymi. Ten wzorzec pozwala algorytmowi zmieniać się niezależnie od klientów, którzy go używają.

![strategy.png](img/strategy.png)

Struktura klas i obiektów:
- Strategia (SortStrategy) - deklaruje zestaw abstrakyjnych metod wspólny dla wszystkich obsługiwanych algorytmów. Kontekst używa tego zestawu do wywołania algorytmu zdefiniowanego przez ConcreteStrategy
- ConcreteStrategy (QuickSort, ShellSort, MergeSort) - implementuje algorytm za pomocą Strategy
- Context (SortedList) - jest skonfigurowany z obiektem ConcreteStrategy. Utrzymuje referencję do obiektu Strategy. Może zdefiniować interfejs, który pozwala Strategii na dostęp do swoich danych.

```cs

public class Program
{
    public static void Main(string[] args)
    {
        // Two contexts following different strategies
        SortedList studentRecords = new SortedList();
        studentRecords.Add("Samual");
        studentRecords.Add("Jimmy");
        studentRecords.Add("Sandra");
        studentRecords.Add("Vivek");
        studentRecords.Add("Anna");
        studentRecords.SetSortStrategy(new QuickSort());
        studentRecords.Sort();
        studentRecords.SetSortStrategy(new ShellSort());
        studentRecords.Sort();
        studentRecords.SetSortStrategy(new MergeSort());
        studentRecords.Sort();
    }
}
// The 'Strategy' abstract class
public abstract class SortStrategy
{
    public abstract void Sort(List<string> list);
}
// A 'ConcreteStrategy' class
public class QuickSort : SortStrategy
{
    public override void Sort(List<string> list)
    {
        list.Sort();  // Default is Quicksort
        Console.WriteLine("QuickSorted list ");
    }
}
// A 'ConcreteStrategy' class
public class ShellSort : SortStrategy
{
    public override void Sort(List<string> list)
    {
        //list.ShellSort();  not-implemented
        Console.WriteLine("ShellSorted list ");
    }
}
// A 'ConcreteStrategy' class
public class MergeSort : SortStrategy
{
    public override void Sort(List<string> list)
    {
        //list.MergeSort(); not-implemented
        Console.WriteLine("MergeSorted list ");
    }
}
// The 'Context' class
public class SortedList
{
    private List<string> list = new List<string>();
    private SortStrategy sortstrategy;
    public void SetSortStrategy(SortStrategy sortstrategy)
    {
        this.sortstrategy = sortstrategy;
    }
    public void Add(string name)
    {
        list.Add(name);
    }
    public void Sort()
    {
        sortstrategy.Sort(list);
        // Iterate over list and display results
        foreach (string name in list)
        {
            Console.WriteLine(" " + name);
        }
        Console.WriteLine();
    }
}

```

#### Template Method

Wzorzec projektowy Template Method definiuje szkielet algorytmu w operacji, odraczając niektóre kroki do podklas. Ten wzorzec pozwala podklasom przedefiniować pewne kroki algorytmu bez zmiany struktury algorytmu.

![template.png](img/template.png)

Struktura klas i obiektów:
- AbstractClass (DataObject) - definiuje abstrakcyjne proste operacje, które konkretne podklasy definiują w celu implementacji kroków algorytmu. Implementuje metodę szablonową definiującą szkielet algorytmu. Metoda szablonu wywołuje prymitywne operacje, jak również operacje zdefiniowane w AbstractClass lub operacje innych obiektów.
- ConcreteClass (CustomerDataObject) - implementuje proste operacje do wykonania specyficznych dla podklasy kroków algorytmu

```cs

public class Program
{
    public static void Main(string[] args)
    {
        DataAccessor categories = new Categories();
        categories.Run(5);
        DataAccessor products = new Products();
        products.Run(3);
    }
}
// The 'AbstractClass' abstract class
public abstract class DataAccessor
{
    public abstract void Connect();
    public abstract void Select();
    public abstract void Process(int top);
    public abstract void Disconnect();
    // The 'Template Method' 
    public void Run(int top)
    {
        Connect();
        Select();
        Process(top);
        Disconnect();
    }
}
// A 'ConcreteClass' class
public class Categories : DataAccessor
{
    private List<string> categories;
    public override void Connect()
    {
        categories = new List<string>();
    }
    public override void Select()
    {
        categories.Add("Red");
        categories.Add("Green");
        categories.Add("Blue");
        categories.Add("Yellow");
        categories.Add("Purple");
        categories.Add("White");
        categories.Add("Black");
    }
    public override void Process(int top)
    {
        Console.WriteLine("Categories ---- ");
        for(int i = 0; i < top; i++)
        {
            Console.WriteLine(categories[i]);
        }
        
        Console.WriteLine();
    }
    public override void Disconnect()
    {
        categories.Clear();
    }
}
// A 'ConcreteClass' class
public class Products : DataAccessor
{
    private List<string> products;
    public override void Connect()
    {
        products = new List<string>();
    }
    public override void Select()
    {
        products.Add("Car");
        products.Add("Bike");
        products.Add("Boat");
        products.Add("Truck");
        products.Add("Moped");
        products.Add("Rollerskate");
        products.Add("Stroller");
    }
    public override void Process(int top)
    {
        Console.WriteLine("Products ---- ");
        for (int i = 0; i < top; i++)
        {
            Console.WriteLine(products[i]);
        }
        Console.WriteLine();
    }
    public override void Disconnect()
    {
        products.Clear();
    }
}

```

#### Visitor

Wzorzec projektowy Visitor reprezentuje operację, która ma być wykonana na elementach struktury obiektowej. Wzorzec ten pozwala na zdefiniowanie nowej operacji bez zmiany klas elementów, na których operuje.

![visitor.png](img/visitor.png)

Struktura klas i obiektów:
- Visitor (Client) - deklaruje operację Visit dla każdej klasy ConcreteElement w strukturze obiektu. Nazwa i sygnatura operacji identyfikuje klasę, która wysyła do visitora żądanie Visit. To pozwala odwiedzającemu określić klasę ConcreteVisitor odwiedzanego elementu. Następnie odwiedzający może uzyskać bezpośredni dostęp do elementów poprzez swój konkretny interfejs
- ConcreteVisitor (IncomeVisitor, VacationVisitor) - implementuje każdą operację zadeklarowaną przez Visitor. Każda operacja implementuje fragment algorytmu zdefiniowanego dla odpowiedniej klasy lub obiektu w strukturze. ConcreteVisitor zapewnia kontekst dla algorytmu i przechowuje jego lokalny stan.
- Element (Element) - definiuje operację Accept, która przyjmuje gościa jako argument.
- ConcreteElement (Pracownik) - implementuje operację Accept, która przyjmuje gościa jako argument.
- ObjectStructure (Pracownicy) - może wyliczać swoje elementy. Może zapewnić interfejs wysokiego poziomu, aby umożliwić odwiedzającemu odwiedzenie jej elementów. Może być Kompozytem (wzorzec) lub kolekcją, taką jak lista lub zbiór

```cs

public class Program
{
    public static void Main(string[] args)
    {
        // Setup employee collection
        Employees employee = new Employees();
        employee.Attach(new Clerk());
        employee.Attach(new Director());
        employee.Attach(new President());
        // Employees are 'visited'
        employee.Accept(new IncomeVisitor());
        employee.Accept(new VacationVisitor());
    }
}
// The 'Visitor' interface
public interface IVisitor
{
    void Visit(Element element);
}
// A 'ConcreteVisitor' class
public class IncomeVisitor : IVisitor
{
    public void Visit(Element element)
    {
        Employee employee = element as Employee;
        // Provide 10% pay raise
        employee.Income *= 1.10;
        Console.WriteLine("{0} {1}'s new income: {2:C}",
            employee.GetType().Name, employee.Name,
            employee.Income);
    }
}
// A 'ConcreteVisitor' class
public class VacationVisitor : IVisitor
{
    public void Visit(Element element)
    {
        Employee employee = element as Employee;
        // Provide 3 extra vacation days
        employee.VacationDays += 3;
        Console.WriteLine("{0} {1}'s new vacation days: {2}",
            employee.GetType().Name, employee.Name,
            employee.VacationDays);
    }
}
// The 'Element' abstract class
public abstract class Element
{
    public abstract void Accept(IVisitor visitor);
}
// The 'ConcreteElement' class
public class Employee : Element
{
    private string name;
    private double income;
    private int vacationDays;
    // Constructor
    public Employee(string name, double income,
        int vacationDays)
    {
        this.name = name;
        this.income = income;
        this.vacationDays = vacationDays;
    }
    public string Name
    {
        get { return name; }
        set { name = value; }
    }
    public double Income
    {
        get { return income; }
        set { income = value; }
    }
    public int VacationDays
    {
        get { return vacationDays; }
        set { vacationDays = value; }
    }
    public override void Accept(IVisitor visitor)
    {
        visitor.Visit(this);
    }
}
// The 'ObjectStructure' class
public class Employees
{
    private List<Employee> employees = new List<Employee>();
    public void Attach(Employee employee)
    {
        employees.Add(employee);
    }
    public void Detach(Employee employee)
    {
        employees.Remove(employee);
    }
    public void Accept(IVisitor visitor)
    {
        foreach (Employee employee in employees)
        {
            employee.Accept(visitor);
        }
        Console.WriteLine();
    }
}
// Three employee types
public class Clerk : Employee
{
    // Constructor
    public Clerk()
        : base("Kevin", 25000.0, 14)
    {
    }
}
public class Director : Employee
{
    // Constructor
    public Director()
        : base("Elly", 35000.0, 16)
    {
    }
}
public class President : Employee
{
    // Constructor
    public President()
        : base("Eric", 45000.0, 21)
    {
    }
}

```


## Literatura

https://learn.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.marshal.allochglobal?redirectedfrom=MSDN&view=net-7.0#System_Runtime_InteropServices_Marshal_AllocHGlobal_System_Int32_

https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/unsafe-code

https://learn.microsoft.com/en-us/dotnet/api/system.intptr?view=net-7.0

https://www.codeproject.com/Articles/1099/Writing-Unsafe-code-using-C

## Literatura

https://learn.microsoft.com/en-us/dotnet/framework/interop/

https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/unsafe-code

https://learn.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.marshal.allochglobal?redirectedfrom=MSDN&view=net-7.0#System_Runtime_InteropServices_Marshal_AllocHGlobal_System_Int32_

https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/unsafe-code

https://learn.microsoft.com/en-us/dotnet/api/system.intptr?view=net-7.0

https://www.codeproject.com/Articles/1099/Writing-Unsafe-code-using-C
